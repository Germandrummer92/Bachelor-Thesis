%% LaTeX2e class for student theses
%% sections/content.tex
%% 
%% Karlsruhe Institute of Technology
%% Institute for Program Structures and Data Organization
%% Chair for Software Design and Quality (SDQ)
%%
%% Dr.-Ing. Erik Burger
%% burger@kit.edu
%%
%% Version 1.1, 2014-11-21

%To be able to reference labels in other file
\externaldocument{introduction}
\externaldocument{appendix}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%--WATERTANK--%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Example-based Refinement on CPS Watertank}
\label{ch:Watertank}

To get a better understanding of the tasks involved in refining a hybrid model into a implementation with all necessary intermediate verification steps, we took a look at one of the out-of-the-box examples provided in the \keym~tutorial~\cite{keYmaera}, a Watertank (See Fig.~\ref{fig:watertank}).

\begin{figure}
	\setcounter{figure}{0}
	\centering
	\includegraphics[width=0.6\textwidth]{images/watertank}
	\caption{Picture of possible Watertank configuration: Watertank that can get drained at all times and has a valve controlled by a control program~\cite{keymaeraGuide}.}
	\label{fig:watertank}
\end{figure}

The ``control'' part of this hybrid system is the valve, it can either drain the watertank with a rate of \(-2\) or it can fill the tank further with a rate of \(1\). The goal of the entire system then is, to keep the water level \(y\) of the tank between \(1\) and \(12\). Normally this is proven by \keym~ without actually implementing a control program. As our goal is to find a concrete implementation,  we first took a look at the hybrid model of the watertank. It is provided both in the form of a hybrid automata (See Fig.~\ref{fig:watertank_ha}) and a hybrid program (See Fig.~\ref{fig:watertank_hp}).

\begin{figure}
	\centering
	\includegraphics[width=0.6\textwidth]{images/watertank_ha}
	\caption{The Watertank CPS expressed as a hybrid automata~\cite{keymaeraGuide}.}
	\label{fig:watertank_ha}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=0.8\textwidth]{images/watertank_hp}
	\caption{The Watertank CPS expressed as a hybrid program~\cite{keymaeraGuide}.}
	\label{fig:watertank_hp}
\end{figure}

\section{Finding the concrete Control Value Assisgnment}
\label{sec:Watertank:ControlValue}

In order to be able to apply Eq.~\ref{eq:Main_LogicRefinement} to this concrete example, the first challenge we faced was finding a spot in which a (or multiple) concrete control value is actually assigned. We call this assignment(s) the \textit{hook} as the actual implementation will ``hook'' into our hybrid model at this exact point. Taking a look at the Hybrid Automata describing the Watertank (See Fig.~\ref{fig:watertank_ha}), it became obvious, that the hybrid model of the watertank required changing to be able to find our actual ``hook''. In the original model, a control value is never explicitly assigned, rather does the valve change its state non-deterministically, making a deterministical control program implementation impossible. Therefore, we tried to remodel the model to better serve our purpose, featuring a clear ticked hook that is called upon at deterministic times. (See Fig.~\ref{fig:watertank_hp_ref}).

\begin{figure}
	\centering
	\includegraphics[width=0.9\textwidth]{images/watertank_hp_ref}
	\caption{The Watertank CPS after remodelling to account for hook.}
	\label{fig:watertank_hp_ref}
\end{figure}

We tried to keep the model mostly equivalent to the original, preserving the 2 clock ticks of time needed for the valve to change its state from drain to fill and vice-versa. This then proved difficult, when trying to think of possible implementations, as the program hook could be called again before the valve would have actually changed its state. To simplify this problem, we decided to only model cases in which the actual program tick (so the time between two hook calls)  is greater than 2 clock ticks (however long they may be).  This means, that the valve or control program doesn't have to have a (possibly infinite) list of the last control values assigned, which could be the case if the program was called more frequently than the valve is able to change states.

\section{Finding the correct Program Safety Condition}
\label{sec:Watertank:SafetyCond}

The next step we attempted was finding the correct postcondition for the program hook (\(\psi\) in Eq.~\ref{eq:Main_LogicRefinement}), which would then serve as the abstraction of the java control program we would later implement. This means, that the program would be built accordingly, so that it could be verified against this postcondition. The original postcondition we devised:

\begin{equation}
	\centering
	\begin{split}
		\psi \equiv ?( y + 2* valve + tick -2 * new  >= 1~\&~ \\ 2 * valve * (tick - 2) * new <= 12~\&~ \\  y + 2* valve >= 1~\&~ y + 2 * valve <= 12) 
	\end{split}
\label{eq:postCondOrig}
\end{equation}

When trying to verify the entire hybrid program (see comment in line 5 of the problem in Fig.~\ref{fig:watertank_hp_ref}), this postcondition did not work. This means, that even in such a simple CPS as this watertank control system, finding the hook postcondition was non-trivial and only with the help of \keym's counterexamples did we manage to find the correct postcondition (See Eq.~\ref{eq:postCondOrigCorrect}). 

\begin{equation}
	\centering
	\begin{split}
		\psi \equiv (?(y + 2 * valve + tick * new >= 1~\& \\ y + 2 * valve + tick * new <= 12~\& \\(new = 1 | new = -2))
	\end{split}
	\label{eq:postCondOrigCorrect}
\end{equation}

\keym~ verified our new hybrid program fully automatically (See Fig.~\ref{fig:KeymaeraVerWatertank}).

\begin{figure}
	\centering
	\includegraphics[width=0.6\textwidth]{images/watertank_keym_ver}
	\caption{The result of automatic verification by \keym~of the Watertank hybrid program that includes our hook (See fig~\ref{fig:watertank_hp_ref}).}
	\label{fig:KeymaeraVerWatertank}
\end{figure}

\section{The (simple) Java Control Program}
\label{sec:Watertank:Java}

After completing verification of our hybrid model with \keym, we proceeded to implement a (simple) control program for the Watertank. Finding a suitable implementation proved difficult, as a parallel implementation (Both the control system and the differential equations working in parallel, modifying the water level) seemed more intuitive. This would defeat the purpose of actually finding a suitable hook and was more based on our understanding of the original hybrid model and not our version including the hook.

Using our understanding of a singular hook of the control system into the Watertank as well as the hook postcondition from the previous section as our specification for the actual control method, that would return the control value to the Watertank's valve, we then managed to implement a suitable discrete control method (See Lst.~\ref{lst:source_controlMethod}).

\definecolor{darkgreen}{rgb}{0.0, 0.2, 0.13}
\lstset{language=Java,captionpos=b,tabsize=3,frame=lines,keywordstyle=\color{blue},commentstyle=\color{darkgreen},stringstyle=\color{red},numbers=left,numberstyle=\tiny,numbersep=5pt,breaklines=true,showstringspaces=false,basicstyle=\footnotesize,emph={label}}
\begin{lstlisting}[label=lst:source_controlMethod]
public int getControlValue (int y, int old) {
		//Waterlevel in two time units
		int inTwo = y + 2 * old;
		//If we are raising level, keep raising if possible without hitting max_level before next tick
		if (old == 10) {
			if (inTwo + tick * 1 <= 116) {
				return 10;
			}
			else {
					return -20;
			}
		}
		//ELSE if we are currently lowering level, keep lowering if we can lower further without hitting min_level b4 next tick
		else {
			if (old == -20) {
				if (inTwo - tick * 2 >= 12) {
					return -20;
				}
				else {
						return 10;
				
				}
		
			}
		}
		//Only returned if old != 10 && old != -20, unreachable.
		return 0;
}
}
\end{lstlisting}

The control method consists only of simple if-else-statements and just assigns the best-case (keep raising level if we were raising, keep lowering if we are lowering as long as postcondition is still valid) value to the valve. We translated the hook postcondition (See  Eq.~\ref{eq:postCondOrig}) into, what we thought to be, a suitable JDL postcondition statement for verification with \key~(See List.~\ref{lst:JDL}). In the next section we will explain why this postcondition would not work for our complete proof. \key~verified our program fully automatically, aside from the fact, that the \(tick>2\) precondition added too much computational complexity, so we let \key~prove the property with the more concrete \(tick==30;~tick==31;\dots\) assignments. See Fig.~\ref{fig:keyVer1},~\ref{fig:keyVer2}.

\begin{figure}
	\centering
	\includegraphics[width=0.4\textwidth]{images/verKey1}
	\caption{Automatic proof result with tick== 30.}
	\label{fig:keyVer1}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=0.4\textwidth]{images/verKey2}
	\caption{Automatic proof result with tick== 31.}
	\label{fig:keyVer2}
\end{figure}


For testing purposes, we also implemented a complete simulator of the Watertank CPS (See App.~\ref{app:Simulator}).

\begin{lstlisting}[label=lst:JDL]
	/*@ public normal_behavior //
	  @ requires tick == 30 && y >= 10 && y <= 120 && y + 2 * old <= 120 && y + 2 * old >= 10 && (old == 10 || old == -20); //
	  @ ensures \result * (tick / 10) + y + 2 * old  >= 12 & \result * (tick / 10) + y + 2 * old <= 116 && (\result == 10 || \result == -20); //
	  @*/
\end{lstlisting} 

\section{Finding the glue between Java and the Hybrid Model of the system}
\label{sec:Watertank:Glue}

The most important and also difficult part of our process, was finding the glue between the real parts of the hybrid system and our java control program. As real values (used in the hybrid model) and discrete values (used in our java implementation) are fundamentally different, a certain transformation has to occur.  In the Watertank example, this means, that the waterlevel as well as the last valve-value (be it fill or drain), which are passed to the control method, have to be converted into one direction by the glue. 

Also, the result of the computation in the method (so the new valve value) has to be converted in the other direction. In general the glue is not necessarily a bijective function, as some values will not exist in both worlds, making it a relation. For the Watertank, fortunately, this problem doe not exist, so finding a function translating the waterlevel and valve values into each other proved relatively easy. 

As we went along, we figured out how a general glue proof should look (See Fig.~\ref{eq:glueGeneral}). Here \(x\) are the discrete values in our control program, \(y\) are the real world values, \(\psi\) is the postcondition of the control program expressed using discrete values and \(\phi\) is the actual safety condition we want to show for the entire hybrid system.

\begin{equation}
	\centering
	\begin{split}
		\forall x \in (Discrete World)~\forall y \in (Real World):(x,y) \in \textit{glue} \implies (\psi(x) \implies \phi(y))
	\end{split}
	\label{eq:glueGeneral}
\end{equation}

Following this basic guideline, we were able to find a suitable glue relation (or in our case a bijective function) for this cps (See Eq.~\ref{eq:glueWatertank}).

\begin{equation}
	\centering
	\begin{split}
		\forall y \in \mathbb{R} . \forall y_j \in \mathbb{Z}. \forall valve \in \mathbb{R}. \forall tick \in \mathbb{R}. \forall tick_j \in \mathbb{Z} . \forall new \in \mathbb{Z}. \forall result \in \mathbb{R} : \\  ((y_j = \textrm{floor}(10 * y) \wedge old_j = \textrm{floor}(10*valve) \wedge tick_j = \textrm{floor}(10*tick) \wedge result = 10 * new \wedge \\ y >= 1 \wedge y <= 12 \wedge (valve = 1  \vee valve = -2) \wedge tick > 2 \implies \\  ((result * tick_j/10 + y_j + 2 * old_j <= 116 \wedge result * tick_j/10 + y_j + 2 * old_j >= 12 \wedge \\ (result = 10 \vee result = -20)) \implies \\ y + 2 * valve + tick * new >= 1 \wedge y + 2 * valve + tick * new <= 12 \wedge \\ (new = 1 \vee new = -2))
	\end{split}
	\label{eq:glueWatertank}
\end{equation}

As can be seen, the \(\psi(x)\) that we found for the glue is not equal to the original trivial postcondition for our java program (See List.~\ref{lst:JDL}). This can be explained by the floor functions that has to be used for translation from the \(\mathbb{R}\) into \(\mathbb{Z}\) world. Due to the usage of the floor function, we only can approximate the original value in the discrete world, and therefore these approximation erorrs have to be accounted for in \(\psi\). Again the fact that we only found this error in our original postcondition devised for the java program, proves the non-triviality of the process even in seemingly simple examples as this watertank.

\section{Verification based on \keym}
\label{sec:Watertank:Verification}

Verification of the glue proved difficult since \keym~ had problems with the floor function. Therefore we found an abstraction of the function using two inequalities to approximate it (See Eq.~\ref{eq:approxF}).

\begin{equation}
	\centering
		f(x) = y \implies x-1 < y \wedge y <= x
	\label{eq:approxF}
\end{equation}

Unfortunately, this still lead to problems when using the automatic proof-mechanism, so we had to add a full new rule fdef to the definition file to be able to use the automatic proover (See List.~\ref{lst:ruleF}).

\lstset{language=Java,captionpos=b,tabsize=3,frame=lines,keywordstyle=\color{black},commentstyle=\color{black},stringstyle=\color{black},numbers=left,numberstyle=\tiny,numbersep=5pt,breaklines=true,showstringspaces=false,basicstyle=\footnotesize,emph={label}}
\begin{lstlisting}[label=lst:ruleF]
	\rules {
 	 	fdef {
			\schemaVar \term R x;
			\schemaVar \skolemTerm R c;
    			\find(f(x))
			\sameUpdateLevel
			\varcond ( \new(c, \dependingOn(x)) )
			\replacewith(c)
			\add(x-1 < c & c <= x & (x >= 0 -> c >= 0) & (x < 0 -> c < 0) ==> )
		};
	}	
\end{lstlisting}

Applying the rule manually to the floor function and changing the first-order-strategy (so the time at which quantifier elimination using mathematica is tried) from lazy (extending every possible leave with case differentiation) to eager (quantifier elimination as soon as possible), the proof runs automatically aside from the application of our own defined rule (See Fig.~\ref{fig:GlueProof}).

\begin{figure}
	\centering
	\includegraphics[width=0.6\textwidth]{images/glue_proof}
	\caption{Successful proof of our glue with \keym.}
	\label{fig:GlueProof}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%--PROCESS--%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction of formalized process of using Refinement to gain a concrete implementation from a hybrid model}
\label{ch:Process}

What the Watertank example shows is the non-triviality of refining the hybrid model into an implementation and of the verification of all necessary parts. Overall it is obvious, that a formalized approach to the general problem presented in chapter~\ref{ch:Introduction} is necessary. In this chapter we present a possible formalized approach to the problem, that we deemed feasible.
\\

To aid readability we will now give an overview of the process without explanation, then detailing each step in the following sections. 

\begin{enumerate}
\item Modelling CPS as Hybrid System that includes concrete hook.
\item Finding the necessary safety condition of the control value for verification with \keym.
\item Implementing control program according to safety condition as its specification and Verification by \key.
\item Finding the correct ``glue'' between hybrid model and control program and its verification by \keym.
\item Result validation: Was Eq.~\ref{eq:Main_LogicRefinement} proven?
\end{enumerate}

\section{Modelling CPS as Hybrid System that includes concrete Hook}
\label{sec:Process:Hook}
Most CPS we took a look at (See \cite{keymaera} Tutorial, \cite[p.~5, p.~11]{platzer2010b} \dots) as examples, did not have a concrete spot in which a control program could ``hook'' in easily. This means, that the first step in our refinement process has to be finding a suitable hook for the control program, referring to one or more non-deterministic assignments of a/multiple control values. Mostly for already existing hybrid systems, as was the case in Sec.~\ref{sec:Watertank:ControlValue}, a complete changing of the model is necessary. When creating a new model, one should try to find a suitable spot for a non-deterministic control value assignment, and if possible already model a form of tick, so as to make an implementation actually feasible.

To prevent issues in later verification of the model, a hybrid program representation of the model should be chosen (cf.~\cite[ch.~1.1.4]{platzer2010b}).

\section{Finding the necessary safety condition of the control value for verification with \keym}
\label{sec:Process:SafetyCond}

After finding a suitable hook spot in our program we have the analyze the hook for a necessary safety condition. If we think back to the watertank example (See ch.~\ref{ch:Watertank:SafetyCond}), this was non-trivial as the first postcondition we came up with logically proved to be incorrect. When thinking of possible conditions we often found we overlooked the tick when considering different postconditions. Obviously, more than one valid postcondition exists, as the constraints imposed on the implementation can get arbirtrarily strong. One should try and find the most general postcondition \(\psi\) for which \keym~still verifies the model, as this makes it easier to code the actual implementation with less constraints.


\section{Implementing control program according to safety condition as its specification and Verification by \key.}
\label{sec:Process:Implementation}

Implementation of the program can theorethically be done in any preferred language, for usage with \key~Java would obviously be the easiest. The implementation is free from any constraints asides from the postcondition that was devised previously, aside from the constraints provided by \key~itself (No threading etc.). Since the postcondition is in the hybrid model and therefore written in the form of real variables and values, one has to already think of a form of the glue that will be formally devised as the next step, as to find a suitable translation of the postcondition expressed with real values into JDL so that \key~can understand. 

The implementation with its postcondition expressed in JDL then has to be verified by \key~before continuing with the glue. 

\section{Finding the correct glue between hybrid model and control program and verifying it with \keym.}
\label{sec:Process:Glue}

As both our model and implementation are now verified, the actual glue between the implementation and the model now has to be devised. In the previous Chapter we came up with a general definition of what the glue relation provides:

\begin{equation}
	\centering
	\begin{split}
		\forall x \in (Discrete World)~\forall y \in (Real World):(x,y) \in \textit{glue} \implies (\psi(x) \implies \phi(y))
	\end{split}
	\tag{\ref{eq:glueGeneral}}
\end{equation}

This means, that for the discrete-world postcondition \(\psi\) that is actually proven by \key~ and the real-world postcondition \(\phi\) that we came up with in step 3, and the glue that we devise, we reach the goal we set out for (See Eq.~\ref{eq:Main_LogicRefinement}). Coming up with the glue is the hardest part of the entire process, and for us took multiple iterations before a correct and verified glue was found. We used a form of logical deduction to come up with the correct quantifiers for the glue proof (so the \(\forall\) in Eq.~\ref{eq:glueGeneral}), which can be found in App.~\ref{app:glueQuant}.

\section{Validating glue results against implementation}
\label{sec:Process:Eval}

As we realized in our Watertank example (See Sec.~\ref{sec:Watertank:Glue}), with verification of our glue some changes might have to be made to the implementation and its postcondition. To complete the process of refinement we have to change the implementation and jdl condition, verify it again with \key~ and make sure all our decisions made were actually valid and correct when taking a look back at the entire picture according to Eq.~\ref{eq:Main_LogicRefinement}).



%% -------------------
%% | Example content |
%% -------------------
\iffalse
The content chapters of your thesis should of course be renamed. How many
chapters you need to write depends on your thesis and cannot be said in general.

Check out the examples theses in the SDQWiki:

\url{https://sdqweb.ipd.kit.edu/wiki/Abschlussarbeit/Studienarbeit}

Of course, you can split this .tex file into several files if you prefer. 


\section{First Section}
\label{sec:FirstContent:FirstSection}

\dots

\section{Second Section}
\label{sec:FirstContent:SecondSection}

\dots


\chapter{Second Content Chapter}
\label{ch:SecondContent}

\dots

\section{First Section}
\label{sec:SecondContent:FirstSection}

\dots

\section{Second Section}
\label{sec:SecondContent:SecondSection}

\dots

Add additional content chapters if required by adding new .tex files in the
\code{sections/} directory and adding an appropriate 
\code{\textbackslash include} statement in \code{thesis.tex}. 
\fi
%% ---------------------
%% | / Example content |
%% ---------------------